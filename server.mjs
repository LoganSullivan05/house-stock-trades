import yahoo from "yahoo-finance2";
import express from 'express';
import fs from 'fs';

function readJSONSync(file){
  return JSON.parse(fs.readFileSync(file).toString());
}

async function getHistoricalData(symbol, last_date) {
  const res = await yahoo.historical(symbol, {
	period1: last_date,
	period2: new Date(),
	interval: "1d"
  });

  return res;
}

async function updateSymbol(symbol){
	try{
		const todays_date = new Date().toDateString();
		if(symbol_updates[symbol] == todays_date) return;
		if(symbol_updates[symbol] > todays_date) return;
		symbol_updates[symbol] = todays_date;

		const file_path = `data/stock_data/${symbol}.json`;
		const trades = readJSONSync(file_path);
		
		const last_date_str = trades[trades.length - 1].date;
		const last_date = new Date(last_date_str);
		last_date.setDate(last_date.getDate() + 1);
		
		const symbol_historical_data = await getHistoricalData(symbol, last_date);
		const symbol_combined_data = [...trades, ...symbol_historical_data];
		fs.writeFileSync(file_path, JSON.stringify(symbol_combined_data));

	}
	catch(e){
		console.log("Error fetching symbol: " + symbol);
		console.log(e);
	}
}

function getStockTradesByFrequency(max_months_ago){

	const symbol_keys_copy = [...symbol_keys];
	// 1M: 1, 1Y: 12, 5Y: 60
	const min_time = new Date();
	// min_time.setFullYear(min_time.getFullYear() - 1);
	min_time.setMonth(min_time.getMonth() - max_months_ago);

	let frequencies = {};

	symbol_keys.forEach(symbol => {
		
		frequencies[symbol] = 0;
		const trades = symbols[symbol];
		
		for(let i=0;i<trades.length;i++){
			const {trade_date} = trades[i];
			if(!trade_date) continue;
			if(new Date(trade_date) > min_time){
				frequencies[symbol]++;
			}
		}
		
	});

	symbol_keys_copy.sort((a,b) => frequencies[b] - frequencies[a]);
	return {frequencies, symbol_keys:symbol_keys_copy};
}

function getInsiderTradesByFrequency(max_months_ago){

	const insider_keys_copy = [...insider_keys];
	const min_time = new Date();
	// min_time.setFullYear(min_time.getFullYear() - 1);
	min_time.setMonth(min_time.getMonth() - max_months_ago);

	let frequencies = {};

	insider_keys.forEach(insider => {
		
		frequencies[insider] = 0;
		const trades = insiders[insider];
		
		for(let i=0;i<trades.length;i++){
			const {trade_date} = trades[i];
			if(!trade_date) continue;
			if(new Date(trade_date) > min_time){
				frequencies[insider]++;
			}
		}
		
	});

	insider_keys_copy.sort((a,b) => frequencies[b] - frequencies[a]);
	return {frequencies, insider_keys:insider_keys_copy};
}

function getCompanyName(symbol){
	if(!meta_data[symbol]) return "Unknown";
	return meta_data[symbol].displayName
	|| meta_data[symbol].shortName
	|| meta_data[symbol].longName 
	|| "Unknown";
}

// ---- article slop -------
let article_slugs = [];

function loadArticleSlugs() {
	const files = fs.readdirSync("website/articles");
	article_slugs = files
		.filter(f => f.endsWith('.html'))
		.map(f => f.replace('.html', ''));
}
loadArticleSlugs();

function getRecommendedArticles(current_slug) {
	const options = article_slugs.filter(slug => slug !== current_slug);
	const shuffled = options.sort(() => 0.5 - Math.random());
	return shuffled.slice(0, 4);
}

function createRecommendationHTML(slugs) {
	return `
<section class="recommended">
	<h2>Recommended Articles</h2>
	<ul>
		${slugs.map(slug => `<li><a href="/articles/${slug}.html">${slug.replace(/-/g, ' ').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</a></li>`).join('\n')}
	</ul>
</section>`;
}

// ---- article slop -------


const app = express();
const port = 3000;

// generated by house_scraper.mjs
const meta_data = readJSONSync("data/meta_data.json");
const symbols = readJSONSync('data/symbol_data.json');
const insiders = readJSONSync('data/insider_data.json');
const symbol_updates = {};
// symbol_updates = readJSONSync("data/symbol_updates.json");


// delete the bad symbols
for(let symbol in symbols){
	if(fs.existsSync(`data/stock_data/${symbol}.json`)) continue;
	delete symbols[symbol];
}

// Using Infinity in dates causes NaN, use large month value for ALL
const symbol_keys = Object.keys(symbols);
symbol_keys.sort((a, b) => symbols[b].length - symbols[a].length);
const symbol_frequency_times = {};

symbol_frequency_times["1M"] = getStockTradesByFrequency(1);
symbol_frequency_times["6M"] = getStockTradesByFrequency(6);
symbol_frequency_times["1Y"] = getStockTradesByFrequency(12);
symbol_frequency_times["5Y"] = getStockTradesByFrequency(60);
symbol_frequency_times["10Y"] = getStockTradesByFrequency(120);
symbol_frequency_times["ALL"] = getStockTradesByFrequency(100000);

const insider_keys = Object.keys(insiders);
insider_keys.sort((a, b) => insiders[b].length - insiders[a].length);
const insider_frequency_times = {};

insider_frequency_times["1M"] = getInsiderTradesByFrequency(1);
insider_frequency_times["6M"] = getInsiderTradesByFrequency(6);
insider_frequency_times["1Y"] = getInsiderTradesByFrequency(12);
insider_frequency_times["5Y"] = getInsiderTradesByFrequency(60);
insider_frequency_times["10Y"] = getInsiderTradesByFrequency(120);
insider_frequency_times["ALL"] = getInsiderTradesByFrequency(100000);


// article slop: add links for SEO

const article_cookie_head = `<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('consent', 'default', {
		'ad_storage': 'denied',
		'analytics_storage': 'denied'
	});
</script>`;


const article_cookie_body = `
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css" />
<script src="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
	window.cookieconsent.initialise({
			palette: {
				popup: { background: "#18181b", text: "#d4d4d8" },
				button: { background: "#6366f1", text: "#ffffff" }
			},
			content: {
			message: "We use cookies for personalized ads and analytics.",
			dismiss: "Accept",
			link: "Privacy Policy",
			href: "/privacy-policy.html"
		},
		onInitialise: function (status) {
			if (status == cookieconsent.status.allow) {
				gtag('consent', 'update', {
					'ad_storage': 'granted',
					'analytics_storage': 'granted'
				});
			}
		}
	});
});
</script>`;

app.set('trust proxy', true);

app.get('/articles_short/:slug.html', async (req, res) => {
	res.status(410).send('Article removed.');
});

app.get('/articles/:slug.html', async (req, res) => {
	const { slug } = req.params;
	
	// backwards compatibility: (underscored URLS were already indexed)
	if (slug.includes('_')) {
		const new_slug = slug.replace(/_/g, '-');
		return res.redirect(301, `/articles/${new_slug}.html`);
	}

	const filePath = `website/articles/${slug}.html`;

	try {
		let html = fs.readFileSync(filePath).toString();

		const recommendations = createRecommendationHTML(getRecommendedArticles(slug));
		const adsense_str = `<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2878584983232027" crossorigin="anonymous"></script>`;
		html = html.replace('</article>', `${recommendations}</article>`);
		html = html.replace('</head>', `${adsense_str}${article_cookie_head}</head>`);
		html = html.replace('</body>', `${article_cookie_body}</body>`);

		res.send(html);
	} catch (err) {
		console.log(err);
		res.status(404).send('Article not found.');
	}
});

app.get("/api/articles", (req, res) => {
	res.json(article_slugs);
});

app.use(express.static('website'));



app.get('/robots.txt', (req, res) => {
	res.end(`User-agent: *
Disallow:`);
});

app.get('/api/stocks/:symbol', async (req, res) => {
	const symbol = req.params.symbol.toUpperCase();
	const file_path = `data/stock_data/${symbol}.json`;
	
	if (!fs.existsSync(file_path)) {
		return res.status(404).json({ error: 'Stock data not found' });
	}
	
	await updateSymbol(symbol);
    const stock_data = readJSONSync(file_path);
    res.json(stock_data);
});

app.get('/api/trades/:symbol', (req, res) => {
	const symbol = req.params.symbol.toUpperCase();

	if (symbols[symbol]) {
		res.json(symbols[symbol]);
	}
	else {
		res.status(404).json({ error: 'No trades found for symbol' });
	}
});

app.get('/api/companies/:symbol', (req, res) => {
	const symbol = req.params.symbol.toUpperCase();
	res.send(getCompanyName(symbol));
});

app.get('/api/list/stocks/:time_range', (req, res) => {
	const time_range = req.params.time_range;
	if (!symbol_frequency_times[time_range]) {
		return res.status(404).json({ error: 'Invalid time range' });
	}

	const { symbol_keys, frequencies } = symbol_frequency_times[time_range];

	const start = parseInt(req.query.start) || 0;
	const end = parseInt(req.query.end) || 100;

	const sliced_symbols = symbol_keys.slice(start, end);	

	const result = sliced_symbols.map(symbol => ({
		symbol: symbol,
		company: getCompanyName(symbol),
		frequency: frequencies[symbol] || 0
	}));

	res.json(result);
});

app.get('/api/list/politicians/:time_range', (req, res) => {
	const time_range = req.params.time_range;
	
	if (!insider_frequency_times[time_range]) {
		return res.status(404).json({ error: 'Invalid time range' });
	}

	const { insider_keys, frequencies } = insider_frequency_times[time_range];

	// Get start/end from query (default to top 100)
	const start = parseInt(req.query.start) || 0;
	const end = insider_keys.length || parseInt(req.query.end) || insider_keys.length;

	const sliced_insiders = insider_keys.slice(start, end);	

	const result = sliced_insiders.map(insider => ({
		insider: insider,
		frequency: frequencies[insider] || 0
	}));

	res.json(result);
});

app.get('/api/politician/:insider', (req, res) => {
	const insider = req.params.insider;
	const decoded_insider = decodeURIComponent(insider);
	
	const trades_raw = insiders[decoded_insider];
	if(!trades_raw){
		return res.status(404).json({ error: 'Politician not found' });
	}

	const trades = trades_raw.filter(trade => {
		return symbols[trade.symbol];
	});

	if (trades) res.json(trades);
	else {
		res.status(404).json({ error: 'Politician not found' });
	}
});

app.listen(port, () => {
	console.log(`Stock tracker API running at http://localhost:${port}`);
});


